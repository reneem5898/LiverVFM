function B = makeBmatrix(x, y, z)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This function makes the B matrix using the "Uniform Strain" method proposed by
% Flanagan et al. 1981 (also used in Abaqus for C3D8R elements)
% APPENDIX I
%
% Inputs: coordinates: x, z and z for hexahedron element
%
% Output: B matrix
%
% Renee Miller
% Date: 26 June 2017
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Nodal permutations
np = [1 2 3 4 5 6 7 8; ...
      2 3 4 1 6 7 8 5; ...
      3 4 1 2 7 8 5 6; ...
      4 1 2 3 8 5 6 7; ...
      5 8 7 6 1 4 3 2; ...
      6 5 8 7 2 1 4 3; ...
      7 6 5 8 3 2 1 4; ...
      8 7 6 5 4 3 2 1];

% Compile matrix of derivatives of shape functions with respect to X, Y and Z
dNdXYZ = zeros(3,8);
for i = 1:8
    % Row 1
    dNdXYZ(1,i) = 1/12 * ( y(np(i,2))* ((z(np(i,6)) - z(np(i,3))) - (z(np(i,4)) - z(np(i,5)))) + y(np(i,3)) * (z(np(i,2)) - z(np(i,4))) + ...
    y(np(i,4)) * ((z(np(i,3)) - z(np(i,8))) - (z(np(i,5)) - z(np(i,2)))) + y(np(i,5)) * ((z(np(i,8)) - z(np(i,6))) - (z(np(i,2)) - z(np(i,4)))) ...
    + y(np(i,6)) * (z(np(i,5)) - z(np(i,2))) + y(np(i,8)) * (z(np(i,4)) - z(np(i,5))) );
    
    % Row 2
    dNdXYZ(2,i) = 1/12 * ( z(np(i,2))* ((x(np(i,6)) - x(np(i,3))) - (x(np(i,4)) - x(np(i,5)))) + z(np(i,3)) * (x(np(i,2)) - x(np(i,4))) + ...
    z(np(i,4)) * ((x(np(i,3)) - x(np(i,8))) - (x(np(i,5)) - x(np(i,2)))) + z(np(i,5)) * ((x(np(i,8)) - x(np(i,6))) - (x(np(i,2)) - x(np(i,4)))) ...
    + z(np(i,6)) * (x(np(i,5)) - x(np(i,2))) + z(np(i,8)) * (x(np(i,4)) - x(np(i,5))) );

    % Row 3
    dNdXYZ(3,i) = 1/12 * ( x(np(i,2))* ((y(np(i,6)) - y(np(i,3))) - (y(np(i,4)) - y(np(i,5)))) + x(np(i,3)) * (y(np(i,2)) - y(np(i,4))) + ...
    x(np(i,4)) * ((y(np(i,3)) - y(np(i,8))) - (y(np(i,5)) - y(np(i,2)))) + x(np(i,5)) * ((y(np(i,8)) - y(np(i,6))) - (y(np(i,2)) - y(np(i,4)))) ...
    + x(np(i,6)) * (y(np(i,5)) - y(np(i,2))) + x(np(i,8)) * (y(np(i,4)) - y(np(i,5))) );
end

% Calculate B matrix (strain matrix)
B = [];
for c = 1:size(dNdXYZ,2) %Loop through number of nodes per element
    Bi = [dNdXYZ(1,c)     0              0; ...
        0            dNdXYZ(2,c)       0; ...
        0               0         dNdXYZ(3,c); ...
        dNdXYZ(2,c)  dNdXYZ(1,c)       0; ...
        dNdXYZ(3,c)     0         dNdXYZ(1,c); ...
        0            dNdXYZ(3,c)  dNdXYZ(2,c)];
    B = [B Bi];
end

end

